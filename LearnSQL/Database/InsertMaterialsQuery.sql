INSERT INTO
    Materials
VALUES
(
  1,
  N'SQL (Structured Query Language) – програмен език, който се използва при достъп до бази данни. 
  Някои възможности на SQL: 
  • Може да изпълнява заявки към база данни 
  • Може да извлича данни от база данни 
  • Може да вмъква записи в база данни 
  • Може да актуализира записи в база данни 
  • Може да изтрие записи от база данни 
  • Може да създава нови бази данни 
  • Може да създава нови таблици в база данни',
  1
)

INSERT INTO
    Materials
VALUES
(
  2,
  N'В SQLSERVER има три основни типа данни: текст, числа и дати.
  Текстовите данни са най-често от някой от изброените типове: 
  • CHAR(size) - Съдържа низ с фиксирания в скобите брой символи 
  • VARCHAR(size)  - Съдържа низ с максимален брой символи броя от скобите 
  • NCHAR(size) - Аналогичен на CHAR, но позволява по обширно кодиране на данните от различни езици 
  • NVARCHAR(size) - Аналогичен на VARCHAR, но позволява по обширно кодиране на данните от различни езици 
  • TINYTEXT - Съдържа стринг с максимална дължина от 255 знака 
  От числовите типове най-често се изпозлват: 
  За целочислени стойности:  
  • INT - Позволява цели числа между-2^31 и 2^31- 1   
  • BIGINT - Позволява цели числа между  2^63 и 2^63  
  • SMALLINT - Позволява цели числа между -2^15 и 2^15  
  • TINYINT - Позволява цели числа от 0 до 255   
  • BIT - В SQL Server няма bool (логически тип) като тип данни, за това в повечето случаи ползваме BIT. Приема стойности 0 и 1 (false и true) 
  При реалните числа: 
  • DECIMAL(P,S) - P показва максималния общ брой цифри, които могат да бъдат съхранени.  Параметърът S показва максималния брой цифри, съхранявани вдясно от десетичната запетая.*  
  • FLOAT(N)  - Данни за плаваща точност от -1.79E + 308 до 1.79E + 308.Параметърът n показва дали полето трябва да съдържа 4 или 8 байта. 
  • REAL - Данни за плаваща точност от -3.40E + 38 до 3.40E + 38 
  За дата и време най-често използваните са: 
  • DATE , Само дата - от 1.01.0001 г. до 31.12.9999 г.  
  • DATETIME , От 1.01.1753 г. до 31.12.9999 г. с точност от 3,33 милисекунди  
  • DATETIME2 , От 1.01.0001 г. до 31.12.9999 г. с точност 100 наносекунди  
  • SMALLDATETIME , От 1.01.1900 г. до 6.06.2079 г. с точност от 1 минута  
  • TIME , Време само с точност от 100 наносекунди   
  ',
  2
)

INSERT INTO
    Materials
VALUES
(
  2,
    N'Таблицата е основния елемент в SQLSERVER. Таблицата съдържа колони, които също се наричат полета, които представляват характеристиките на обекта. Редовете или записите в таблицата описват характеристиките на даден обект.
    Всяка таблица изисква специално поле наречено първичен ключ. Първичния ключ се използва за връзка с други таблици. Той трябва да се слага на поле, което бива рядко променяно и типа на данни да е прост. 
Таблицата се създава с: CREATE TABLE <Name> 
Пример: CREATE TABLE Students 
Полетата в таблицата се дефинират: <Name> <Type> 
Пример: Name NVARCHAR(30) 
Ако искаме да създадем таблица за ученици с номер, име и фамилия то тогава командите ще изглеждат така: 
CREATE TABLE Students 
( 
    ID INT PRIMARY KEY, 
    FirstName NVARCHAR(30) NOT NULL, 
    LastName NVARCHAR(30) NOT NULL 
) 
Слагаме ID-то да е първичен ключ и е от тип INT, а името и фамилията от тип NVARCHAR(30), като им слагаме ограничение да не са празни - NOT NULL.',
  2
)

INSERT INTO
    Materials
VALUES
(
  3,
    N'Таблицата е основния елемент в SQLSERVER. Таблицата съдържа колони, които също се наричат полета, които представляват характеристиките на обекта. Редовете или записите в таблицата описват характеристиките на даден обект.
    Всяка таблица изисква специално поле наречено първичен ключ. Първичния ключ се използва за връзка с други таблици. Той трябва да се слага на поле, което бива рядко променяно и типа на данни да е прост. 
Таблицата се създава с: CREATE TABLE <Name> 
Пример: CREATE TABLE Students 
Полетата в таблицата се дефинират: <Name> <Type> 
Пример: Name NVARCHAR(30) 
Ако искаме да създадем таблица за ученици с номер, име и фамилия то тогава командите ще изглеждат така: 
CREATE TABLE Students 
( 
    ID INT PRIMARY KEY, 
    FirstName NVARCHAR(30) NOT NULL, 
    LastName NVARCHAR(30) NOT NULL 
) 
Слагаме ID-то да е първичен ключ и е от тип INT, а името и фамилията от тип NVARCHAR(30), като им слагаме ограничение да не са празни - NOT NULL.',
  3
)

INSERT INTO
    Materials
VALUES
(
  4,
    N'Тъй като базата данни съдържа много повече от една релация, трябва да направим начин, по който тези таблици да могат да се свързват. Това се случва благодарение на първичния ключ и чуждия ключ. За първичния ключ говорихме в урока за създаване на таблици. Чуждият ключ е поле в дадена таблица, което осъществява връзка с първичен ключ в друга таблица.  
Ако създадем таблица Subjects с поле име на предмет: 
CREATE TABLE Subjects 
( 
    ID INT PRIMARY KEY, 
    Name NVARCHAR(30) NOT NULL 
); 
Можем да допълним таблицата ни Students с ново поле благодарение на командата ALTER TABLE: 
ALTER TABLE <TableName> 
ADD FavouriteSubject INT FOREIGN KEY REFERENCES Subjects(ID) 
 
Синтаксиса за създаване на чужд ключ изглежда по следния начин: 
<ColumnName> <DataType> REFERENCES <ReferencedTable> (<ReferencedTablePK) 
Преди обаче да се добави чуждия ключ, трябва да се разбере каква връзка между таблиците ще се ползва. 
• Ако ползвате връзка 1-към-1 (един обект от едната таблица се отнася към един обект от другата) (най-редкият тип), то тогава свързвате двата първични ключа 
• Ако ползвате връзка 1-към-много (един обект от едната таблица може да се отнася към много обекти от другата)(най-разпространено), то тогава свързвате първичен ключ и чужд ключ. 
• Ако ползвате връзка много-към-много (много обекти от едната таблица може да се отнасят към много обекти от другата), то тогава ви трябва трета таблица, наречена свързваща, която съдържа чуждите ключове, които реферират двете таблици.
',
  4
)

INSERT INTO
    Materials
VALUES
(
  5,
    N'   След като създадем таблиците, за да може да имаме полза от тях, трябва да ги напълним с информация. Както казахме в урока за таблиците, полетата в таблиците ни показват какви характеристики обектите, докато самите записи дават конкретните стойности. В SQLSERVER, като искаме да добавим информация към таблица ползваме следната команда: 
INSERT INTO <TableName> VALUES (<param1>, <param2>…., <paramN>); 
Ако продължим примера от предния урок, ако искаме да добавим нов ученик в таблицата, пишем: 
INSERT INTO Students VALUES (1, ‘Александър’, ‚Александров‘, 2); 
',
  5
)

INSERT INTO
    Materials
VALUES
(
  6,
    N'   Информацията, която съхраняваме в базата ще ни бъде излишна, ако не я извличаме по някакъв начин. С командата:
SELECT <Fields> FROM <Table>
Изкарваме информацията от поисканите полета от дадената таблица. Ако искаме да изкараме информацията от всички полета в таблицата, може да използваме съркратения синтаксис:
SELECT * FROM <Table>.
',
  6
)

INSERT INTO
    Materials
VALUES
(
  7,
    N'   Може резултатите да сортираме по някакъв начин – ORDER BY, във възходящ - ASC и респективно низходящ – DESC ред.
Ако вземем таблицата Students и искаме да вземем имената и да ги сортираме по азбучен ред, то тогава заявката ще изглежда по начина: 
SELECT FirstName, LastName FROM Students ORDER BY FirstName THEN BY LastName 
Клаузата SELECT TOP се използва за определяне на броя на записите за връщане.
Агрегатни функции 
Агрегатните функции ни позволят да правим обобщения по множество от стойности, да търсим мин. или макс. елемент в такова множество и др. Функциите са: 
• SUM(); 
• MAX(); 
• MIN(); 
• AVG(); 
• COUNT(); 
В скобите обикновено присъства име на колона, за която желаем да бъде приложена агрегатната функция. 
 Не се случва особено често да искаме абсолютно цялата информация от таблицата. Искаме само информацията, подбрана по някакъв критерий. Когато искаме да филтрираме информацията използваме WHERE в комбинация с условие. Ако искаме да вземем информацията за ученика с първи номер от таблицата Students, то тогава: SELECT * FROM Students WHERE ID = 1. Ако решим да вземем имената на учениците между 1 и 12 номер, то тогава ги взимаме с оператора BETWEEN: SELECT FirstName FROM Students WHERE ID BETWEEN 1 AND 12. Можем да вземем и всички ученици, които не се казват Александър: SELECT * FROM Students WHERE FirstName != ‘Александър’ 
',
  7
)

INSERT INTO
    Materials
VALUES
(
  8,
    N'  За извличане и обработване на данни от повече от една свързани таблици се извършва съединяване на таблиците в заявка, което обикновено се изразява в комбиниране на колоните на първичните и външните ключове (на съответните таблици) на съответстващите редове.
INNER JOIN е връзката между таблици по подразбиране
Може да се запише само JOIN 
Тя връща само редовете, отговарящина условието за свързване.
Например, ако освен таблицата Students, имаме и таблица за техните класни ръководители (ClassTeachers). Връзката между двете таблици ще е едно към много. Защо? Защото един ученик може да има един класен ръководител, докато класният ръководител е такъв на група ученици. Следователно в таблицата Students ще имаме поле ClassTeacherID, което ще е от типа на първичния ключ за таблицата ClassTeachers и ще е външен ключ за таблицата Students. Тогава, за да изведем имената на учениците и имената ка тежните класни ръководители, ще кажем така:
SELECT Students.Name, Students.Surname, ClassTeachers.Name, ClassTeachers.Surname FROM Students
JOIN ClassTeachers
ON ClassTeachers.ID=Students.ClassTeacherID
',
  8
)